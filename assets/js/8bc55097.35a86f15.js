"use strict";(self.webpackChunkdeveloper_docs=self.webpackChunkdeveloper_docs||[]).push([[53626],{15680:(e,a,t)=>{t.d(a,{xA:()=>u,yg:()=>g});var n=t(96540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),c=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=c(e.components);return n.createElement(s.Provider,{value:a},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},p=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(t),p=r,g=m["".concat(s,".").concat(p)]||m[p]||d[p]||l;return t?n.createElement(g,i(i({ref:a},u),{},{components:t})):n.createElement(g,i({ref:a},u))}));function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=p;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=t[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}p.displayName="MDXCreateElement"},19365:(e,a,t)=>{t.d(a,{A:()=>i});var n=t(96540),r=t(20053);const l={tabItem:"tabItem_Ymn6"};function i(e){let{children:a,hidden:t,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.A)(l.tabItem,i),hidden:t},a)}},11470:(e,a,t)=>{t.d(a,{A:()=>N});var n=t(58168),r=t(96540),l=t(20053),i=t(23104),o=t(56347),s=t(57485),c=t(31682),u=t(89466);function m(e){return function(e){var a,t;return null!=(a=null==(t=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?a:[]}(e).map((e=>{let{props:{value:a,label:t,attributes:n,default:r}}=e;return{value:a,label:t,attributes:n,default:r}}))}function d(e){const{values:a,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=a?a:m(t);return function(e){const a=(0,c.X)(e,((e,a)=>e.value===a.value));if(a.length>0)throw new Error('Docusaurus error: Duplicate values "'+a.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[a,t])}function p(e){let{value:a,tabValues:t}=e;return t.some((e=>e.value===a))}function g(e){let{queryString:a=!1,groupId:t}=e;const n=(0,o.W6)(),l=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:a,groupId:t});return[(0,s.aZ)(l),(0,r.useCallback)((e=>{if(!l)return;const a=new URLSearchParams(n.location.search);a.set(l,e),n.replace({...n.location,search:a.toString()})}),[l,n])]}function y(e){const{defaultValue:a,queryString:t=!1,groupId:n}=e,l=d(e),[i,o]=(0,r.useState)((()=>function(e){var a;let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+n.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(a=n.find((e=>e.default)))?a:n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:a,tabValues:l}))),[s,c]=g({queryString:t,groupId:n}),[m,y]=function(e){let{groupId:a}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(a),[n,l]=(0,u.Dv)(t);return[n,(0,r.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:n}),h=(()=>{const e=null!=s?s:m;return p({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{h&&o(h)}),[h]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);o(e),c(e),y(e)}),[c,y,l]),tabValues:l}}var h=t(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:a,block:t,selectedValue:o,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:m}=(0,i.a_)(),d=e=>{const a=e.currentTarget,t=u.indexOf(a),n=c[t].value;n!==o&&(m(a),s(n))},p=e=>{var a;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var n;const a=u.indexOf(e.currentTarget)+1;t=null!=(n=u[a])?n:u[0];break}case"ArrowLeft":{var r;const a=u.indexOf(e.currentTarget)-1;t=null!=(r=u[a])?r:u[u.length-1];break}}null==(a=t)||a.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":t},a)},c.map((e=>{let{value:a,label:t,attributes:i}=e;return r.createElement("li",(0,n.A)({role:"tab",tabIndex:o===a?0:-1,"aria-selected":o===a,key:a,ref:e=>u.push(e),onKeyDown:p,onClick:d},i,{className:(0,l.A)("tabs__item",b.tabItem,null==i?void 0:i.className,{"tabs__item--active":o===a})}),null!=t?t:a)})))}function v(e){let{lazy:a,children:t,selectedValue:n}=e;const l=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,a)=>(0,r.cloneElement)(e,{key:a,hidden:e.props.value!==n}))))}function w(e){const a=y(e);return r.createElement("div",{className:(0,l.A)("tabs-container",b.tabList)},r.createElement(f,(0,n.A)({},e,a)),r.createElement(v,(0,n.A)({},e,a)))}function N(e){const a=(0,h.A)();return r.createElement(w,(0,n.A)({key:String(a)},e))}},71807:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>u,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>c,toc:()=>m});var n=t(58168),r=(t(96540),t(15680)),l=t(11470),i=t(19365);const o={id:"dynamic-batching",title:"Dynamic Batching",sidebar_label:"Dynamic Batching",description:"How Dynamic Batching works and how it can help you optimide your playables.",keywords:["luna","dynamic","batching","playable","luna"]},s=void 0,c={unversionedId:"playable/optimise-your-builds/dynamic-batching",id:"playable/optimise-your-builds/dynamic-batching",title:"Dynamic Batching",description:"How Dynamic Batching works and how it can help you optimide your playables.",source:"@site/docs/playable/optimise-your-builds/dynamic-batching.md",sourceDirName:"playable/optimise-your-builds",slug:"/playable/optimise-your-builds/dynamic-batching",permalink:"/docs/playable/optimise-your-builds/dynamic-batching",draft:!1,tags:[],version:"current",frontMatter:{id:"dynamic-batching",title:"Dynamic Batching",sidebar_label:"Dynamic Batching",description:"How Dynamic Batching works and how it can help you optimide your playables.",keywords:["luna","dynamic","batching","playable","luna"]},sidebar:"gettingStarted",previous:{title:"Excluding Assets",permalink:"/docs/playable/optimise-your-builds/excluding-assets"},next:{title:"Runtime Performance",permalink:"/docs/playable/optimise-your-builds/runtime-performance"}},u={},m=[{value:"Draw Call Conditions",id:"draw-call-conditions",level:2},{value:"How does Dynamic Batching work with Playable Plugin?",id:"how-does-dynamic-batching-work-with-playable-plugin",level:2},{value:"Examples",id:"examples",level:3},{value:"Supported Features",id:"supported-features",level:2},{value:"Unity versions support",id:"unity-versions-support",level:2},{value:"Limitations and Performance Characteristics",id:"limitations-and-performance-characteristics",level:2},{value:"Recommendations for using Dynamic Batching",id:"recommendations-for-using-dynamic-batching",level:3},{value:"User Guide",id:"user-guide",level:2}],d={toc:m},p="wrapper";function g(e){let{components:a,...o}=e;return(0,r.yg)(p,(0,n.A)({},d,o,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Dynamic Batching is an optimization technique used in rendering engines to reduce overhead on the draw calls issuing process by merging several draw calls into single one."),(0,r.yg)("p",null,"Dynamic Batching aims to ",(0,r.yg)("strong",{parentName:"p"},"improve performance on older and less powerful devices"),". However, with modern consumer hardware, the CPU workload associated with dynamic batching can exceed the benefits of minimizing draw calls, ultimately leading to a decrease in performance."),(0,r.yg)("h2",{id:"draw-call-conditions"},"Draw Call Conditions"),(0,r.yg)("p",null,"A single draw call is ",(0,r.yg)("em",{parentName:"p"},"batchable")," if the following conditions are met:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"Dynamic Batching")," option is enabled in the Playable Plugin Window."),(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"Mesh")," used by the draw call is indexed (uses Index Buffer)."),(0,r.yg)("li",{parentName:"ul"},"The draw call is not rendered using instanced rendering (e.g. particle systems are not batchable).")),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"Skinned meshes are not batchable.")),(0,r.yg)("p",null,"Two draw calls could be batched if the following conditions are met:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"Material")," instance used by both draw calls is the same."),(0,r.yg)("li",{parentName:"ul"},"The shader keywords used by both draw calls are the same.",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Both draw calls should use the same shader features (e.g. lightmaps, shadows)."))),(0,r.yg)("li",{parentName:"ul"},"Mesh parameters/Uniforms used in rendering are the same for both draw calls."),(0,r.yg)("li",{parentName:"ul"},"Sort keys are the same.",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"The rendering order of the draw call could be changed without an effect on the rendered frame."))),(0,r.yg)("li",{parentName:"ul"},"The layout of the Vertex Buffer should be the same for both draw calls.",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Both meshes should have similar data (e.g. Position, Texture Coordinates, Color).")))),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"Dynamic Batching cannot be applied to GameObjects that have mirroring within their ",(0,r.yg)("inlineCode",{parentName:"p"},"Transform")," component."),(0,r.yg)("p",{parentName:"admonition"},"For example, if two GameObjects have different scales, with one having a scale of 1 and the other having a scale of -1, they cannot be batched together. See ",(0,r.yg)("a",{parentName:"p",href:"https://docs.unity3d.com/Manual/DrawCallBatching.html"},"Unity Documentation")," for more details.")),(0,r.yg)("h2",{id:"how-does-dynamic-batching-work-with-playable-plugin"},"How does Dynamic Batching work with Playable Plugin?"),(0,r.yg)("p",null,"Playable tries to lower pressure on both CPU and GPU by not calculating batches every frame, instead it caches previously allocated batches, and recalculates them only when there is a breaking change that makes some of the batch data incorrect."),(0,r.yg)("p",null,"This could occur if any of the following conditions are met:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The hierarchy of the scene has changed",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"The affected batches will be recalculated."))),(0,r.yg)("li",{parentName:"ul"},"The vertex buffer of one or more of the instances has changed (typically happens during animations)."),(0,r.yg)("li",{parentName:"ul"},"The mesh parameters have changed.")),(0,r.yg)("p",null,"However, Playable will not recalculate batches if there was any other changes. A position change, for example, reuses previously allocated batches."),(0,r.yg)("p",null,"Although data buffers that contain vertices and indices will remain unchanged, modifications to the transform (position, rotation, or scale) will result in changes to the Model matrix, which are then applied and updated. This approach saves rendering time while maintaining the visual integrity of the image."),(0,r.yg)("h3",{id:"examples"},"Examples"),(0,r.yg)(l.A,{groupId:"dynamic-batching-examples",defaultValue:"1",values:[{label:"Example 1",value:"1"},{label:"Example 2",value:"2"},{label:"Example 3",value:"3"}],mdxType:"Tabs"},(0,r.yg)(i.A,{value:"1",mdxType:"TabItem"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:"images-small",src:t(8780).A,width:"682",height:"1214"})," ",(0,r.yg)("br",null),(0,r.yg)("br",null))),(0,r.yg)(i.A,{value:"2",mdxType:"TabItem"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:"images-small",src:t(59463).A,width:"690",height:"1202"})," ",(0,r.yg)("br",null),(0,r.yg)("br",null))),(0,r.yg)(i.A,{value:"3",mdxType:"TabItem"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:"images-small",src:t(83678).A,width:"646",height:"1198"})," ",(0,r.yg)("br",null),(0,r.yg)("br",null)))),(0,r.yg)("h2",{id:"supported-features"},"Supported Features"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Supported"),(0,r.yg)("th",{parentName:"tr",align:null},"Comment"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"UI"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null},"Supports all types of Canvas UI (Overlay, Camera, World), and all built-in UI elements (Image, Text, Toggle, etc.)")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"2D"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"3D"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null},"Except: Particle Systems and Skinned Meshes")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Built-in Rendering Pipeline (BIRP)"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Universal Rendering Pipeline (URP)"),(0,r.yg)("td",{parentName:"tr",align:null},"No"),(0,r.yg)("td",{parentName:"tr",align:null},"Dynamic Batching works only in BIRP at the moment")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"High Definition Rendering Pipeline (HDRP)"),(0,r.yg)("td",{parentName:"tr",align:null},"No"),(0,r.yg)("td",{parentName:"tr",align:null},"Dynamic Batching works only in BIRP at the moment")))),(0,r.yg)("h2",{id:"unity-versions-support"},"Unity versions support"),(0,r.yg)("p",null,"Dynamic Batching works on ",(0,r.yg)("a",{parentName:"p",href:"/docs/playable/faq#which-versions-of-unity-do-you-support"},"all versions of Unity that Playable can run"),"."),(0,r.yg)("h2",{id:"limitations-and-performance-characteristics"},"Limitations and Performance Characteristics"),(0,r.yg)("p",null,"Dynamic Batching could increase performance in some scenes, especially if the scene contains many similar objects that are close to each other in the hierarchy. For other scenes, if there are many/all different objects or similar objects scattered across the hierarchy, it does not impact performance or make it inefficient for some devices. Please, measure performance on the target devices to see the performance changes for the scene while using Dynamic Batching."),(0,r.yg)("p",null,"If there is a breaking change in the batch (",(0,r.yg)("a",{parentName:"p",href:"#how-does-dynamic-batching-work-with-playable-plugin"},"see the previous section for details"),") the Playable Plugin will regenerate this batch by allocating new GPU buffers and merging meshes together. In cases where breaking changes occur frequently for many batches, performance can be worse than if Dynamic Batching wasn't used."),(0,r.yg)("p",null,"The amount of draw calls that could be batched together and the time to make a batch depends on device capabilities. On some low-end devices if scene contains many complex objects (complex meshes or shaders), Dynamic Batching could perform worse than regular rendering without Dynamic Batching."),(0,r.yg)("h3",{id:"recommendations-for-using-dynamic-batching"},"Recommendations for using Dynamic Batching"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Use the same material for multiple objects."),(0,r.yg)("li",{parentName:"ul"},"Keep similar objects close in the hierarchy."),(0,r.yg)("li",{parentName:"ul"},"Animated objects should be separated from non-animated objects in the hierarchy."),(0,r.yg)("li",{parentName:"ul"},"Try to group objects in the hierarchy the same way as described in the ",(0,r.yg)("a",{parentName:"li",href:"/docs/playable/optimise-your-builds/dynamic-batching#draw-call-conditions"},"above"),".",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"See conditions for when two draw calls could be batched."))),(0,r.yg)("li",{parentName:"ul"},"Measure the playable performance on the target device.")),(0,r.yg)("admonition",{title:"important",type:"danger"},(0,r.yg)("p",{parentName:"admonition"},"If Dynamic Batching is negatively impacting performance or resulting in distortions in the final image, it is recommended to turn it off."),(0,r.yg)("p",{parentName:"admonition"},"Please report any issues with Dynamic Batching to our support team via ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("a",{parentName:"strong",href:"https://playground.lunalabs.io/applications"},"Creative Suite"))," Intercom.")),(0,r.yg)("h2",{id:"user-guide"},"User Guide"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Open a project of your choice."),(0,r.yg)("li",{parentName:"ol"},"Import the Playable Plugin plugin."),(0,r.yg)("li",{parentName:"ol"},"Create or open existing scene."),(0,r.yg)("li",{parentName:"ol"},"Add batchable objects to your scene.",(0,r.yg)("ol",{parentName:"li"},(0,r.yg)("li",{parentName:"ol"},"see our ",(0,r.yg)("a",{parentName:"li",href:"/docs/playable/optimise-your-builds/dynamic-batching#supported-features"},"supported features for Dynamic Batching")," to check what objects are batchable."))),(0,r.yg)("li",{parentName:"ol"},"Open the Playable Plugin Window and enable Dynamic Batching:",(0,r.yg)("ol",{parentName:"li"},(0,r.yg)("li",{parentName:"ol"},"Check ",(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("em",{parentName:"strong"},"Settings \u2192 Advanced \u2192 Dynamic Batching option")),(0,r.yg)("img",{alt:"images-medium",src:t(38453).A,width:"2224",height:"1708"})))),(0,r.yg)("li",{parentName:"ol"},"Export the project and test the results:",(0,r.yg)("ol",{parentName:"li"},(0,r.yg)("li",{parentName:"ol"},"You can make sure batching is working by taking a look at the frame debugger (See the ",(0,r.yg)("a",{parentName:"li",href:"/docs/playable/code/luna-in-browser/spector-js/#spector-argument"},"spector argument documentation"),"). In the captured frame you could see that some of the draw calls are rendering several objects (use scene with disabled Dynamic Batching for comparison)."),(0,r.yg)("li",{parentName:"ol"},"You can also toggle Dynamic Batching in runtime, and measure performance, for that you could use built-in fps counter. See ",(0,r.yg)("a",{parentName:"li",href:"/docs/playable/optimise-your-builds/fps-counter"},"FPS Counter"),".")))))}g.isMDXComponent=!0},8780:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/dynamic-batching-test1-d749cd672ff6c66bdb31cbfb72289465.png"},59463:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/dynamic-batching-test2-fb206a0a9ce95f90085992f38072b634.png"},83678:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/dynamic-batching-test3-b1321a989cb5ad14ed764bbdee8682da.png"},38453:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/dynamic-batching-option-d61e45a0b38931a79b0b8cb2f0eb954b.png"}}]);