"use strict";(self.webpackChunkdeveloper_docs=self.webpackChunkdeveloper_docs||[]).push([[307],{15680:(e,n,r)=>{r.d(n,{xA:()=>u,yg:()=>g});var t=r(96540);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=t.createContext({}),p=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(r),d=i,g=c["".concat(s,".").concat(d)]||c[d]||m[d]||a;return r?t.createElement(g,o(o({ref:n},u),{},{components:r})):t.createElement(g,o({ref:n},u))}));function g(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=r[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}d.displayName="MDXCreateElement"},17829:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var t=r(58168),i=(r(96540),r(15680));const a={id:"runtime-performance",title:"Runtime Performance",sidebar_label:"Runtime Performance",description:"Examples & tips to help you identify & optimise your C# code for better runtime performance on the Luna Engine.",keywords:["runtime","performance","tips","optimise","playable","luna"]},o=void 0,l={unversionedId:"playable/optimise-your-builds/runtime-performance",id:"playable/optimise-your-builds/runtime-performance",title:"Runtime Performance",description:"Examples & tips to help you identify & optimise your C# code for better runtime performance on the Luna Engine.",source:"@site/docs/playable/optimise-your-builds/runtime-performance.md",sourceDirName:"playable/optimise-your-builds",slug:"/playable/optimise-your-builds/runtime-performance",permalink:"/docs/playable/optimise-your-builds/runtime-performance",draft:!1,tags:[],version:"current",frontMatter:{id:"runtime-performance",title:"Runtime Performance",sidebar_label:"Runtime Performance",description:"Examples & tips to help you identify & optimise your C# code for better runtime performance on the Luna Engine.",keywords:["runtime","performance","tips","optimise","playable","luna"]},sidebar:"gettingStarted",previous:{title:"Dynamic Batching",permalink:"/docs/playable/optimise-your-builds/dynamic-batching"},next:{title:"FPS Counter",permalink:"/docs/playable/optimise-your-builds/fps-counter"}},s={},p=[{value:"Accessing Data",id:"accessing-data",level:2},{value:"Caching",id:"caching",level:2},{value:"Storing structures",id:"storing-structures",level:3},{value:"Storing vectors",id:"storing-vectors",level:3},{value:"Allocation reduction",id:"allocation-reduction",level:2}],u={toc:p},c="wrapper";function m(e){let{components:n,...r}=e;return(0,i.yg)(c,(0,t.A)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"When building your playable experience in Unity, and C#, it is important to keep in mind that the end result will be running in HTML5 on a web browser. As such, optimising the performance as much as possible will result in higher-performing user experiences, with better device support and ultimately, ad performance."),(0,i.yg)("p",null,"We've assembled a number of examples and tips which will help you identify and optimise your C# code for better runtime performance on the Luna engine."),(0,i.yg)("h2",{id:"accessing-data"},"Accessing Data"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Use Arrays instead of lists.")),(0,i.yg)("p",null,"When translating lists in C# to JavaScript, there are a number of additional check (such as methods to check whether the data is out of range) which add unnecessary overhead. Therefore, we recommend that you use ",(0,i.yg)("inlineCode",{parentName:"p"},"arrays")," instead of ",(0,i.yg)("inlineCode",{parentName:"p"},"lists")," where possible."),(0,i.yg)("p",null,"An example is using ",(0,i.yg)("inlineCode",{parentName:"p"},"LINQ")," in your game to loop through lists, as this can result in performance issues if this process is repetitive. Generally avoid using LINQ loops during the gameplay to iterate through lists."),(0,i.yg)("p",null,"Although this operation is usually fine on start, it can be expensive during the gameplay."),(0,i.yg)("p",null,"Functions like ",(0,i.yg)("inlineCode",{parentName:"p"},"List<>.FindAll()")," methods are really expensive, we have seen these used and can cause performance lags, especially when comparing enums as this adds additional overhead."),(0,i.yg)("p",null,"Where ever possible try to cache references, reducing these calls eliminates the need to:"),(0,i.yg)("p",null,"\u2022 Search the list."),(0,i.yg)("p",null,"\u2022 Compare the elements multiple times."),(0,i.yg)("p",null,"Thus improving performance."),(0,i.yg)("p",null,"On top of caching using a regular ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," loop to iterate an array is much more efficient method than using LINQ to loop through lists. So if you have to iterate through, use ",(0,i.yg)("inlineCode",{parentName:"p"},"arrays")," and use regular ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," loops where possible."),(0,i.yg)("p",null,"Don't do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"public List<int> Values;\n")),(0,i.yg)("p",null,"Do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"public int[] Values;\n")),(0,i.yg)("h2",{id:"caching"},"Caching"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Store and reuse structures as much as possible.")),(0,i.yg)("p",null,"When your C# is transpiled to JavaScript, every call (especially for a structure) will lead to duplication in memory. Therefore you should try to store and reuse as much as possible."),(0,i.yg)("h3",{id:"storing-structures"},"Storing structures"),(0,i.yg)("p",null,"Don't do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"for (int index = 0; index < Triangles.Count; index++)\n{\n  var tri = Triangles[index];\n  // grab local variables for easier access\n  var vA = new Vertex(tri.idA, tri.posA, tri.uvA, tri.normalA /*, tri.tangentA, tri.colorA*/);\n\n    /* Do something with vA, having it as a temp value */\n}\n")),(0,i.yg)("p",null,"Do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"var count = Triangles.Length;\nTriangle tri = new Triangle();\nvar vA = new Vertex();\nfor (int index = 0; index < count; index++)\n{\n  tri.Set( Triangles[index]);\n  // grab local variables for easier access\n  vA.Set(tri.idA, tri.posA, tri.uvA, tri.normalA /*, tri.tangentA, tri.colorA*/);\n\n  /* Note here Triangle and Vertex are Structures and Set method reuses them */\n}\n")),(0,i.yg)("h3",{id:"storing-vectors"},"Storing vectors"),(0,i.yg)("p",null,"Using ",(0,i.yg)("inlineCode",{parentName:"p"},"vector.x")," is very common, yet add minor overhead in JavaScript since ",(0,i.yg)("inlineCode",{parentName:"p"},".x")," is a property which must be accessed."),(0,i.yg)("p",null,"Don't do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"var n = plane.normal;\n")),(0,i.yg)("p",null,"Do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"var normalX = plane.normal.x;\nvar normalY = plane.normal.y;\nvar normalZ = plane.normal.z;\n")),(0,i.yg)("h2",{id:"allocation-reduction"},"Allocation reduction"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Pass structures into methods as a reference to avoid cloning.")),(0,i.yg)("p",null,"One of the most common use cases for allocations is passing structs in/out of methods."),(0,i.yg)("p",null,"To improve this in JavaScript, you can make use of the specific Bridge attribute, ","[Ref]","."),(0,i.yg)("p",null,"For example, a heavy Triangle structure being passed into a method:\nDon't Do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"public void Set( Triangle triangle){**}\n/* This will lead to it being cloned at the moment it is called. */\n")),(0,i.yg)("p",null,"Do:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cs"},"public void Set( [Ref] Triangle triangle){**}\n/* This way the structure is passed as a reference and no cloning will happen.{**}\n   Note: To get rid of missing attribute, wrap usage and method in defines: */\n\n#if UNITY_LUNA\nusing Bridge;\n#endif\n\n#if UNITY_LUNA\npublic void Set( [Ref] Triangle triangle);\n\n#else\npublic void Set( Triangle triangle);\n#endif\n")))}m.isMDXComponent=!0}}]);